#!/usr/bin/env perl

use strict;
use warnings;

use Getopt::Long;

my $retry_file;
my $failures = '/tmp/run-modified-tests.failures';

GetOptions(
  'quiet' => \(my $quiet = 0),
  'run!' => \(my $run = 1),
  'ret|retry' => sub {
    my $arg = shift;
    $retry_file = $failures;
    if (length($arg) && -f $arg) {
      $retry_file = $arg;
    }
  },
  'h|help' => sub { exit 0 * print(usage()) },
);

sub apply (&@) {
  my $code = shift;
  $code->() foreach @_;
  return @_;
}

# chomp(my $root = `git rev-parse --show-toplevel`);
# chdir $root;
chdir "/home/dev/src/adama";

my @tests = modified_tests($retry_file);

if (! $run) {
  print join(' ', @tests), "\n";
} else {
  my $verbose_flag = $quiet
    ? ''
    : ' --verbose';

  my $test_results = "/tmp/run-modified-tests.$$.out";
  system("(/usr/bin/env prove -Ilib -It/lib $verbose_flag @tests 2>&1) | tee $test_results");

  my @failed =
    apply { s/^(\S+).*$/$1/ }
    grep {
      $_ =~ /Test Summary Report/ ... $_ =~ /Result/
        ? $_ =~ /Wstat/
        : 0;
    }
    catfile($test_results);

  if (@failed) {
    chomp @failed;
    open my $fh, '+>', $failures or die "open $failures: $!\n";
    print($fh "$_\n") foreach @failed;
    close $fh;
    print <<"END";

Test failures, see $test_results

END
    exit 1;
  }
}

exit 0;

sub catfile {
  my ($file) = @_;
  local @ARGV = ($file);
  (<>);
}

sub unzip (&@) {
  my $code = shift;
  my ($l, $r) = ([], []);
  foreach (@_) {
    my $ar = $code->() ? $l : $r;
    push @$ar, $_;
  }
  return ($l, $r);
}

sub modified_tests {
  my ($retry_file) = @_;

  if ($retry_file) {
    chomp(my @tests = catfile($retry_file));
    return @tests;
  } else {

    chomp(my @affected = `git status --porcelain`);
    my ($ts, $pms) =
      unzip { m{\.t$} }
        grep { m{t/lib/Adama/Test.*\.pm$} || m{\.t$} }
        apply { s/^..//; s/^\W+// }
          grep { $_ !~ /^\s*D/ }
          @affected;

    # turn list of .pm files into a list of classes
    @$pms = apply {
      s{t/lib/}{};
      s{/}{::}g;
      s{\.pm$}{};
    } @$pms;

    my $modules = join '|', @$pms;
    my $command = qq{git grep -l -E '($modules)->runtests';};
    chomp(my @module_runners = `$command`);
    if (@module_runners != @$pms) {
      die(<<"YIKES");
Yikes! couldn't find a runner for all modules!

given:
${\join "\n", map { "  $_" } @$pms}

got:
${\join "\n", map { "  $_" } @module_runners}
YIKES
    }

    return (@$ts, @module_runners);
  }
}

sub usage {
  return <<USAGE;
run-modified-tests [--quiet] [--norun] [--retry]

Find modified tests in the Adama codebase and run them.

Options:

  --run       default: --run
  --norun     don't actually run tests, just tell what we'd run

  --quiet     by default, 'prove' is run in --verbose mode.
              'run-modified-tests --quiet' will make your testrun
              a little more quiet.

  --retry     re-run failed tests from the last run-modified-tests testrun.
              The idea is that you 'run-modified-tests' once. Some tests will
              pass, others will fail. You begin working your way through the
              list of failures, making them pass, and periodically running
              'run-modified-tests --retry' to winnow the list of failure down.
  --retry FILE  like --retry, but use the tests listed in FILE instead of the
                cached file from the last testrun.
USAGE
}
