(provide 'belden-perl-introspection)
(require 'string)

(defun current-method-call ()
  (parse-method (current-method)))
(defun current-method-method ()
  (car (cdr (parse-method (current-method)))))
(defun current-method-class ()
  (car (parse-method (current-method))))

(defun parse-method (mod-string)
  (let (pathlist function arrow super)
    (setq arrow (string-match "->" mod-string))
    (setq pathlist (reverse (string-split "::\\|->" mod-string)))
    (setq function (pop pathlist))
    (setq super (pop pathlist))
    (if (string-equal super "SUPER")
        (setq function (format "%s::%s" super function))
	(push super pathlist))
    (if (and (not arrow)
             (or (not (or (downcasep function) (starts-with function "_")))
                 (null pathlist)))
        (progn (push function pathlist) (setq function 'nil)))
    (list (list-join (reverse pathlist) "::") function)))

(defun filename-to-module (filename)
  (if (string-match "\\.pm$" filename)
      (progn
        (setq filename (string-replace-match "\\.pm$" filename ""))
        (setq filename (string-replace-match ".*\\/lib\\/" filename ""))
        (if filename (list-join (string-split "\\/" filename) "::")
          'nil)
        )
    nil))
(defun buffer-file-module ()
  (if (buffer-file-name) (filename-to-module (buffer-file-name))))

(defun module-on-point-or-current-module ()
  (if (point-on-modulep) (current-module) (buffer-file-module)))

(defun current-method ()
  (save-excursion
    (skip-chars-forward "A-Za-z0-9:_\\-")
    (if (char-equal (previous-char) "-") (backward-char 1))
    (let ((end (point)) beg)
      (skip-chars-backward "A-Za-z0-9:_\\")
      (skip-chars-backward "->")
      (skip-chars-backward "A-Za-z0-9:_\\")
      (setq beg (point))
      (if (string= (buffer-substring (- (point) 7) (point)) "->new()")
          (let (end2 beg2)
            (backward-char 7)
            (setq end2 (point))
            (skip-chars-backward "A-Za-z0-9:_\\")
            (setq beg2 (point))
            (concat (buffer-substring beg2 end2) (buffer-substring beg end))
            )
        (if (string= (buffer-substring (point) (+ (point) 5)) "new->")
            (let (end2 beg2)
              (setq beg (+ (point) 3))
              (backward-char 2)
              (setq end2 (point))
              (skip-chars-backward "A-Za-z0-9:_\\")
              (setq beg2 (point))
              (concat (buffer-substring beg2 end2) (buffer-substring beg end))
              )
          (buffer-substring beg end))))))

(defun current-function ()
  (save-excursion
    (skip-chars-backward "A-Za-z0-9_\\-")
    (let ((beg (point)))
      (skip-chars-forward "A-Za-z0-9_\\-")
      (buffer-substring beg (point)))))

(defun current-variable ()
  (save-excursion
    (let (beg variable)
      (if (looking-at "[@$%]") (forward-char 1))
      (skip-chars-backward "{A-Za-z0-9_")
      (setq beg (1- (point)))
      (if (looking-at "{") (skip-chars-forward "{A-Za-z0-9_")
        (skip-chars-forward "A-Za-z0-9_"))
      (setq variable (buffer-substring beg (point)))
      (or (string-replace-match "{" variable "" 'nil t) variable)
      )))

(defun current-module ()
  (save-excursion
    (skip-chars-backward "A-Za-z0-9:_")
    (let ((beg (point)) module curclass)
      (skip-chars-forward "A-Za-z0-9:_")
      (setq module (buffer-substring beg (point)))
      (when (string-match ":$" module)
        (setq module (string-replace-match ":+$" module "")))
      (when (string-match "^::" module)
        (setq curclass (belden-perl-currentclass))
        (message "Assuming class is %s" curclass)
        (sit-for 0.2)
        (setq module (format "%s%s" curclass module)))
      module
      )))

(defun belden-perl-currentclass ()
  (let ((filename (buffer-file-name)) new-filename)
    (if (string-match "\\.t$" filename)
        (setq new-filename (belden-code-test-map filename)))
    (if new-filename (setq filename new-filename))
    (belden-filename-to-modulename filename)))

(defun belden-filename-to-modulename (file)
  (interactive)
  (let ((base (shuttershutter)))
    (setq file
          (or
           (string-replace-match
            (format "^%s%s" base "/lib/") file "")
           (string-replace-match ".*perl/" file "")
           file
           ))
    (setq file (string-replace-match "\\.pm\$" file ""))
    (string-replace-match "/" file "::" 't 't)
    ))

(defun empty-line-suffix () (only-whitespace (current-line-suffix)))
(defun empty-line-prefix () (only-whitespace (current-line-prefix)))
(defun only-whitespace (str) (and (string-match "^[ \r\t]*\$" str) 't))

; moving within blocks of perlcode
(defun current-pblock-boundaries ()
  (save-excursion
    (let (pblock-beg)
      (belden-backward-to-current-pblock)
      (setq pblock-beg (point))
      (belden-forward-to-current-pblock)
      (list pblock-beg (point)))))

(defun belden-backward-to-current-pblock ()
  (interactive)
  (if (not (looking-at "[\(\{]")) (belden-backward-to-enclosing-pblock)))
(defun belden-forward-to-current-pblock ()
  (interactive)
  (if (not (looking-at "[\)\}]")) (belden-forward-to-enclosing-pblock)))

(defun belden-forward-to-enclosing-pblock ()
  "Go forward to enclosing paren or brace block"
  (interactive)
  (let ((brace-count 0) (paren-count 0) (start (point)))
    (forward-char 1)
    (while (and (not (= brace-count 1))
                (not (= paren-count 1))
                (not (eobp))
                (search-forward-regexp "[\(\)\{\}]" nil t))
      (progn
        (backward-char 1)
        (if (looking-at "{") (setq brace-count (1- brace-count)))
        (if (looking-at "}") (setq brace-count (1+ brace-count)))
        (if (looking-at "(") (setq paren-count (1- paren-count)))
        (if (looking-at ")") (setq paren-count (1+ paren-count)))
        (forward-char 1)
        )
      )
    (backward-char 1)
    (if (and (not (= brace-count 1)) (not (= paren-count 1)))
        (progn (goto-char start)
               (error "belden-forward-to-enclosing-block: At top level")))
    (if (and (= brace-count 1) (not (= paren-count 0)))
        (error "belden-forward-to-enclosing-block: Mismatched parens"))
    (if (and (= paren-count 1) (not (= brace-count 0)))
        (error "belden-forward-to-enclosing-block: Mismatched braces"))
    )
  )

(defun belden-backward-to-enclosing-pblock ()
  "Go backward to enclosing paren or brace block"
  (interactive)
  (let ((brace-count 0) (paren-count 0) (start (point)))
    (while (and (not (= brace-count 1))
                (not (= paren-count 1))
                (not (bobp))
                (search-backward-regexp "[\(\)\{\}]" nil t)
                )
      (progn
        (if (looking-at "{") (setq brace-count (1+ brace-count)))
        (if (looking-at "}") (setq brace-count (1- brace-count)))
        (if (looking-at "(") (setq paren-count (1+ paren-count)))
        (if (looking-at ")") (setq paren-count (1- paren-count)))
        )
      )
    (if (and (not (= brace-count 1)) (not (= paren-count 1)))
        (progn (goto-char start)
               (error "belden-backward-to-enclosing-block: At top level")))
    (if (and (= brace-count 1) (not (= paren-count 0)))
        (error "belden-backward-to-enclosing-block: Mismatched parens"))
    (if (and (= paren-count 1) (not (= brace-count 0)))
        (error "belden-backward-to-enclosing-block: Mismatched braces"))
    )
  )
